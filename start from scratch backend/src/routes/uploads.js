const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const mongoose = require('mongoose');
const Upload = require('../models/Upload'); // Import the Upload model
const Project = require('../models/Project'); // To validate projectId

// --- Multer Configuration ---

// Define storage settings for multer
const storage = multer.diskStorage({
  // Destination folder for uploads
  destination: function (req, file, cb) {
    // IMPORTANT: Ensure the 'uploads/' directory exists in your backend root!
    const uploadPath = path.join(__dirname, '..', '..', 'uploads'); // Go up two levels from src/routes to backend root
    // TODO: Consider checking if uploadPath exists and creating if not (fs.mkdirSync maybe?)
    cb(null, uploadPath);
  },
  // Define how files should be named
  filename: function (req, file, cb) {
    // Create a unique filename: timestamp + random number + original extension
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'file-' + uniqueSuffix + path.extname(file.originalname)); // Simpler prefix
  }
});

// Optional: File filter (example: accept only PDFs and images)
// const fileFilter = (req, file, cb) => {
//   if (file.mimetype === 'application/pdf' || file.mimetype.startsWith('image/')) {
//     cb(null, true); // Accept file
//   } else {
//     cb(new Error('Invalid file type. Only PDF and image files are allowed.'), false); // Reject file
//   }
// };

// Initialize multer with storage settings
const upload = multer({
  storage: storage,
  // limits: { fileSize: 1024 * 1024 * 10 }, // Optional: Limit file size (e.g., 10MB)
  // fileFilter: fileFilter // Optional: Apply the file filter
});

// --- Route Definition ---

// POST /api/uploads
// Handles file upload and saves metadata
// 'file' should match the name attribute of the file input field in the frontend form
router.post('/', upload.single('file'), async (req, res) => {
  // If multer encounters an error it will be passed here or via an error handler middleware

  // Check if a file was actually uploaded by multer
  if (!req.file) {
    // This might happen if fileFilter rejects the file
    return res.status(400).json({ msg: 'No file uploaded or file type rejected.' });
  }

  // Extract additional data sent along with the file (from FormData)
  const { projectId, title, description } = req.body;

  // --- Validation ---
  if (!projectId) {
     // TODO: Delete orphaned file if validation fails after multer saved it
     // fs.unlinkSync(req.file.path); <-- Be careful with sync operations
    return res.status(400).json({ msg: 'Project ID is required.' });
  }
  if (!mongoose.Types.ObjectId.isValid(projectId)) {
    // TODO: Delete orphaned file
    return res.status(400).json({ msg: 'Invalid Project ID format.' });
  }

  try {
    // Verify the project exists
    const projectExists = await Project.findById(projectId);
    if (!projectExists) {
        // TODO: Delete orphaned file
        return res.status(404).json({ msg: 'Project not found.' });
    }

    // --- Save Metadata to DB ---
    const newUpload = new Upload({
      projectId: projectId,
      filename: req.file.filename,       // Name generated by multer
      originalName: req.file.originalname, // Original name from user
      mimeType: req.file.mimetype,       // File type
      path: req.file.path,             // Full path where multer saved it
                                       // Note: We might want to store a relative path or just the filename
                                       // depending on how we construct URLs later. Storing the full path
                                       // might be less portable. Let's adjust to store relative path.
      // path: `uploads/${req.file.filename}`, // Store relative path
      size: req.file.size,             // File size in bytes
      title: title || req.file.originalname, // Default title to original name if not provided
      description: description         // User-provided description (optional)
    });

    // Adjust path before saving:
    newUpload.path = `uploads/${req.file.filename}`; // Store relative path


    const savedUpload = await newUpload.save();

    // Respond with the saved metadata (frontend will likely need this)
    res.status(201).json(savedUpload);

  } catch (err) {
    console.error('Error saving upload metadata:', err);
     if (err.name === 'ValidationError') {
        // TODO: Delete orphaned file
        const errors = Object.values(err.errors).map(el => el.message);
        return res.status(400).json({ msg: 'Validation Error saving metadata', errors: errors });
    }
    // Need to potentially delete the orphaned file if DB save fails
    // const fs = require('fs'); // Requires fs module
    // try { fs.unlinkSync(req.file.path); } catch (unlinkErr) { console.error("Error deleting orphaned file:", unlinkErr); }
    res.status(500).send('Server Error saving upload metadata.');
  }
});

// --- Export Router ---
module.exports = router;